// Code generated by Wire protocol buffer compiler, do not edit.
// Source: cryptauthv2.SyncKeysResponse in cryptauth/cryptauth_enrollment.proto
@file:Suppress("DEPRECATION")

package cryptauthv2

import com.squareup.wire.EnumAdapter
import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.ReverseProtoWriter
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireEnum
import com.squareup.wire.WireField
import com.squareup.wire.`internal`.JvmField
import com.squareup.wire.`internal`.JvmStatic
import com.squareup.wire.`internal`.JvmSynthetic
import com.squareup.wire.`internal`.checkElementsNotNull
import com.squareup.wire.`internal`.immutableCopyOf
import com.squareup.wire.`internal`.redactElements
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.Suppress
import kotlin.Unit
import kotlin.collections.List
import okio.ByteString

/**
 * The response to SyncKeysRequest. The response instructs how the client should
 * manage existing keys and whether to create a new key.
 */
public class SyncKeysResponse(
  /**
   * The session indentifer generated by the server, which must be
   * cryptographically random.
   */
  @field:WireField(
    tag = 1,
    adapter = "com.squareup.wire.ProtoAdapter#BYTES",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "randomSessionId",
    schemaIndex = 0,
  )
  @JvmField
  public val random_session_id: ByteString = ByteString.EMPTY,
  /**
   * The ephemeral DH public key generated by the server.
   */
  @field:WireField(
    tag = 2,
    adapter = "com.squareup.wire.ProtoAdapter#BYTES",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "serverEphemeralDh",
    schemaIndex = 1,
  )
  @JvmField
  public val server_ephemeral_dh: ByteString = ByteString.EMPTY,
  sync_single_key_responses: List<SyncSingleKeyResponse> = emptyList(),
  /**
   * The updated client-specific directives.
   */
  @field:WireField(
    tag = 4,
    adapter = "cryptauthv2.ClientDirective#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "clientDirective",
    schemaIndex = 3,
  )
  @JvmField
  public val client_directive: ClientDirective? = null,
  /**
   * A client-specific opaque blob given to the application.
   */
  @field:WireField(
    tag = 5,
    adapter = "com.squareup.wire.ProtoAdapter#BYTES",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "clientAppDirective",
    schemaIndex = 4,
  )
  @JvmField
  public val client_app_directive: ByteString = ByteString.EMPTY,
  /**
   * The status of the server.
   */
  @field:WireField(
    tag = 6,
    adapter = "cryptauthv2.SyncKeysResponse${'$'}ServerStatus#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "serverStatus",
    schemaIndex = 5,
  )
  @JvmField
  public val server_status: ServerStatus = ServerStatus.SERVER_OK,
  unknownFields: ByteString = ByteString.EMPTY,
) : Message<SyncKeysResponse, SyncKeysResponse.Builder>(ADAPTER, unknownFields) {
  /**
   * Per key sync response.
   */
  @field:WireField(
    tag = 3,
    adapter = "cryptauthv2.SyncKeysResponse${'$'}SyncSingleKeyResponse#ADAPTER",
    label = WireField.Label.REPEATED,
    jsonName = "syncSingleKeyResponses",
    schemaIndex = 2,
  )
  @JvmField
  public val sync_single_key_responses: List<SyncSingleKeyResponse> =
      immutableCopyOf("sync_single_key_responses", sync_single_key_responses)

  override fun newBuilder(): Builder {
    val builder = Builder()
    builder.random_session_id = random_session_id
    builder.server_ephemeral_dh = server_ephemeral_dh
    builder.sync_single_key_responses = sync_single_key_responses
    builder.client_directive = client_directive
    builder.client_app_directive = client_app_directive
    builder.server_status = server_status
    builder.addUnknownFields(unknownFields)
    return builder
  }

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is SyncKeysResponse) return false
    if (unknownFields != other.unknownFields) return false
    if (random_session_id != other.random_session_id) return false
    if (server_ephemeral_dh != other.server_ephemeral_dh) return false
    if (sync_single_key_responses != other.sync_single_key_responses) return false
    if (client_directive != other.client_directive) return false
    if (client_app_directive != other.client_app_directive) return false
    if (server_status != other.server_status) return false
    return true
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + random_session_id.hashCode()
      result = result * 37 + server_ephemeral_dh.hashCode()
      result = result * 37 + sync_single_key_responses.hashCode()
      result = result * 37 + (client_directive?.hashCode() ?: 0)
      result = result * 37 + client_app_directive.hashCode()
      result = result * 37 + server_status.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    result += """random_session_id=$random_session_id"""
    result += """server_ephemeral_dh=$server_ephemeral_dh"""
    if (sync_single_key_responses.isNotEmpty()) result +=
        """sync_single_key_responses=$sync_single_key_responses"""
    if (client_directive != null) result += """client_directive=$client_directive"""
    result += """client_app_directive=$client_app_directive"""
    result += """server_status=$server_status"""
    return result.joinToString(prefix = "SyncKeysResponse{", separator = ", ", postfix = "}")
  }

  public fun copy(
    random_session_id: ByteString = this.random_session_id,
    server_ephemeral_dh: ByteString = this.server_ephemeral_dh,
    sync_single_key_responses: List<SyncSingleKeyResponse> = this.sync_single_key_responses,
    client_directive: ClientDirective? = this.client_directive,
    client_app_directive: ByteString = this.client_app_directive,
    server_status: ServerStatus = this.server_status,
    unknownFields: ByteString = this.unknownFields,
  ): SyncKeysResponse = SyncKeysResponse(random_session_id, server_ephemeral_dh,
      sync_single_key_responses, client_directive, client_app_directive, server_status,
      unknownFields)

  public class Builder : Message.Builder<SyncKeysResponse, Builder>() {
    @JvmField
    public var random_session_id: ByteString = ByteString.EMPTY

    @JvmField
    public var server_ephemeral_dh: ByteString = ByteString.EMPTY

    @JvmField
    public var sync_single_key_responses: List<SyncSingleKeyResponse> = emptyList()

    @JvmField
    public var client_directive: ClientDirective? = null

    @JvmField
    public var client_app_directive: ByteString = ByteString.EMPTY

    @JvmField
    public var server_status: ServerStatus = ServerStatus.SERVER_OK

    /**
     * The session indentifer generated by the server, which must be
     * cryptographically random.
     */
    public fun random_session_id(random_session_id: ByteString): Builder {
      this.random_session_id = random_session_id
      return this
    }

    /**
     * The ephemeral DH public key generated by the server.
     */
    public fun server_ephemeral_dh(server_ephemeral_dh: ByteString): Builder {
      this.server_ephemeral_dh = server_ephemeral_dh
      return this
    }

    /**
     * Per key sync response.
     */
    public fun sync_single_key_responses(sync_single_key_responses: List<SyncSingleKeyResponse>):
        Builder {
      checkElementsNotNull(sync_single_key_responses)
      this.sync_single_key_responses = sync_single_key_responses
      return this
    }

    /**
     * The updated client-specific directives.
     */
    public fun client_directive(client_directive: ClientDirective?): Builder {
      this.client_directive = client_directive
      return this
    }

    /**
     * A client-specific opaque blob given to the application.
     */
    public fun client_app_directive(client_app_directive: ByteString): Builder {
      this.client_app_directive = client_app_directive
      return this
    }

    /**
     * The status of the server.
     */
    public fun server_status(server_status: ServerStatus): Builder {
      this.server_status = server_status
      return this
    }

    override fun build(): SyncKeysResponse = SyncKeysResponse(
      random_session_id = random_session_id,
      server_ephemeral_dh = server_ephemeral_dh,
      sync_single_key_responses = sync_single_key_responses,
      client_directive = client_directive,
      client_app_directive = client_app_directive,
      server_status = server_status,
      unknownFields = buildUnknownFields()
    )
  }

  public companion object {
    @JvmField
    public val ADAPTER: ProtoAdapter<SyncKeysResponse> = object : ProtoAdapter<SyncKeysResponse>(
      FieldEncoding.LENGTH_DELIMITED, 
      SyncKeysResponse::class, 
      "type.googleapis.com/cryptauthv2.SyncKeysResponse", 
      PROTO_3, 
      null, 
      "cryptauth/cryptauth_enrollment.proto"
    ) {
      override fun encodedSize(`value`: SyncKeysResponse): Int {
        var size = value.unknownFields.size
        if (value.random_session_id != ByteString.EMPTY) size +=
            ProtoAdapter.BYTES.encodedSizeWithTag(1, value.random_session_id)
        if (value.server_ephemeral_dh != ByteString.EMPTY) size +=
            ProtoAdapter.BYTES.encodedSizeWithTag(2, value.server_ephemeral_dh)
        size += SyncSingleKeyResponse.ADAPTER.asRepeated().encodedSizeWithTag(3,
            value.sync_single_key_responses)
        if (value.client_directive != null) size += ClientDirective.ADAPTER.encodedSizeWithTag(4,
            value.client_directive)
        if (value.client_app_directive != ByteString.EMPTY) size +=
            ProtoAdapter.BYTES.encodedSizeWithTag(5, value.client_app_directive)
        if (value.server_status != ServerStatus.SERVER_OK) size +=
            ServerStatus.ADAPTER.encodedSizeWithTag(6, value.server_status)
        return size
      }

      override fun encode(writer: ProtoWriter, `value`: SyncKeysResponse) {
        if (value.random_session_id != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer, 1,
            value.random_session_id)
        if (value.server_ephemeral_dh != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer,
            2, value.server_ephemeral_dh)
        SyncSingleKeyResponse.ADAPTER.asRepeated().encodeWithTag(writer, 3,
            value.sync_single_key_responses)
        if (value.client_directive != null) ClientDirective.ADAPTER.encodeWithTag(writer, 4,
            value.client_directive)
        if (value.client_app_directive != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer,
            5, value.client_app_directive)
        if (value.server_status != ServerStatus.SERVER_OK)
            ServerStatus.ADAPTER.encodeWithTag(writer, 6, value.server_status)
        writer.writeBytes(value.unknownFields)
      }

      override fun encode(writer: ReverseProtoWriter, `value`: SyncKeysResponse) {
        writer.writeBytes(value.unknownFields)
        if (value.server_status != ServerStatus.SERVER_OK)
            ServerStatus.ADAPTER.encodeWithTag(writer, 6, value.server_status)
        if (value.client_app_directive != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer,
            5, value.client_app_directive)
        if (value.client_directive != null) ClientDirective.ADAPTER.encodeWithTag(writer, 4,
            value.client_directive)
        SyncSingleKeyResponse.ADAPTER.asRepeated().encodeWithTag(writer, 3,
            value.sync_single_key_responses)
        if (value.server_ephemeral_dh != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer,
            2, value.server_ephemeral_dh)
        if (value.random_session_id != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer, 1,
            value.random_session_id)
      }

      override fun decode(reader: ProtoReader): SyncKeysResponse {
        var random_session_id: ByteString = ByteString.EMPTY
        var server_ephemeral_dh: ByteString = ByteString.EMPTY
        val sync_single_key_responses = mutableListOf<SyncSingleKeyResponse>()
        var client_directive: ClientDirective? = null
        var client_app_directive: ByteString = ByteString.EMPTY
        var server_status: ServerStatus = ServerStatus.SERVER_OK
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> random_session_id = ProtoAdapter.BYTES.decode(reader)
            2 -> server_ephemeral_dh = ProtoAdapter.BYTES.decode(reader)
            3 -> sync_single_key_responses.add(SyncSingleKeyResponse.ADAPTER.decode(reader))
            4 -> client_directive = ClientDirective.ADAPTER.decode(reader)
            5 -> client_app_directive = ProtoAdapter.BYTES.decode(reader)
            6 -> try {
              server_status = ServerStatus.ADAPTER.decode(reader)
            } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
              reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
            }
            else -> reader.readUnknownField(tag)
          }
        }
        return SyncKeysResponse(
          random_session_id = random_session_id,
          server_ephemeral_dh = server_ephemeral_dh,
          sync_single_key_responses = sync_single_key_responses,
          client_directive = client_directive,
          client_app_directive = client_app_directive,
          server_status = server_status,
          unknownFields = unknownFields
        )
      }

      override fun redact(`value`: SyncKeysResponse): SyncKeysResponse = value.copy(
        sync_single_key_responses =
            value.sync_single_key_responses.redactElements(SyncSingleKeyResponse.ADAPTER),
        client_directive = value.client_directive?.let(ClientDirective.ADAPTER::redact),
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L

    @JvmSynthetic
    public inline fun build(body: Builder.() -> Unit): SyncKeysResponse =
        Builder().apply(body).build()
  }

  /**
   * The response corresponding to the SyncSingleKeyRequest message.
   */
  public class SyncSingleKeyResponse(
    key_actions: List<KeyAction> = emptyList(),
    /**
     * Instruction for key creation.
     */
    @field:WireField(
      tag = 2,
      adapter = "cryptauthv2.SyncKeysResponse${'$'}SyncSingleKeyResponse${'$'}KeyCreation#ADAPTER",
      label = WireField.Label.OMIT_IDENTITY,
      jsonName = "keyCreation",
      schemaIndex = 1,
    )
    @JvmField
    public val key_creation: KeyCreation = KeyCreation.NONE,
    /**
     * The type of the cryptographic key.
     */
    @field:WireField(
      tag = 3,
      adapter = "cryptauthv2.KeyType#ADAPTER",
      label = WireField.Label.OMIT_IDENTITY,
      jsonName = "keyType",
      schemaIndex = 2,
    )
    @JvmField
    public val key_type: KeyType = KeyType.KEY_TYPE_UNSPECIFIED,
    /**
     * The updated key-specific directives.
     */
    @field:WireField(
      tag = 4,
      adapter = "cryptauthv2.KeyDirective#ADAPTER",
      label = WireField.Label.OMIT_IDENTITY,
      jsonName = "keyDirective",
      schemaIndex = 3,
    )
    @JvmField
    public val key_directive: KeyDirective? = null,
    /**
     * A key-specific opaque blob given to the application.
     */
    @field:WireField(
      tag = 5,
      adapter = "com.squareup.wire.ProtoAdapter#BYTES",
      label = WireField.Label.OMIT_IDENTITY,
      jsonName = "keyAppDirective",
      schemaIndex = 4,
    )
    @JvmField
    public val key_app_directive: ByteString = ByteString.EMPTY,
    /**
     * The storage level to create the key.
     */
    @field:WireField(
      tag = 6,
      adapter =
          "cryptauthv2.SyncKeysResponse${'$'}SyncSingleKeyResponse${'$'}KeyStorageLevel#ADAPTER",
      label = WireField.Label.OMIT_IDENTITY,
      jsonName = "keyStorageLevel",
      schemaIndex = 5,
    )
    @JvmField
    public val key_storage_level: KeyStorageLevel = KeyStorageLevel.KEY_STORAGE_LEVEL_UNSPECIFIED,
    /**
     * The newly created key should require hardware backed user presence when
     * using the key.
     */
    @field:WireField(
      tag = 7,
      adapter = "com.squareup.wire.ProtoAdapter#BOOL",
      label = WireField.Label.OMIT_IDENTITY,
      jsonName = "hardwareUserPresenceRequired",
      schemaIndex = 6,
    )
    @JvmField
    public val hardware_user_presence_required: Boolean = false,
    /**
     * The newly created key should require user verification when using the
     * key.
     */
    @field:WireField(
      tag = 8,
      adapter = "com.squareup.wire.ProtoAdapter#BOOL",
      label = WireField.Label.OMIT_IDENTITY,
      jsonName = "userVerificationRequired",
      schemaIndex = 7,
    )
    @JvmField
    public val user_verification_required: Boolean = false,
    unknownFields: ByteString = ByteString.EMPTY,
  ) : Message<SyncSingleKeyResponse, SyncSingleKeyResponse.Builder>(ADAPTER, unknownFields) {
    /**
     * Key actions with one entry per key handle and in the same order as in the
     * request.
     */
    @field:WireField(
      tag = 1,
      adapter = "cryptauthv2.SyncKeysResponse${'$'}SyncSingleKeyResponse${'$'}KeyAction#ADAPTER",
      label = WireField.Label.REPEATED,
      jsonName = "keyActions",
      schemaIndex = 0,
    )
    @JvmField
    public val key_actions: List<KeyAction> = immutableCopyOf("key_actions", key_actions)

    override fun newBuilder(): Builder {
      val builder = Builder()
      builder.key_actions = key_actions
      builder.key_creation = key_creation
      builder.key_type = key_type
      builder.key_directive = key_directive
      builder.key_app_directive = key_app_directive
      builder.key_storage_level = key_storage_level
      builder.hardware_user_presence_required = hardware_user_presence_required
      builder.user_verification_required = user_verification_required
      builder.addUnknownFields(unknownFields)
      return builder
    }

    override fun equals(other: Any?): Boolean {
      if (other === this) return true
      if (other !is SyncSingleKeyResponse) return false
      if (unknownFields != other.unknownFields) return false
      if (key_actions != other.key_actions) return false
      if (key_creation != other.key_creation) return false
      if (key_type != other.key_type) return false
      if (key_directive != other.key_directive) return false
      if (key_app_directive != other.key_app_directive) return false
      if (key_storage_level != other.key_storage_level) return false
      if (hardware_user_presence_required != other.hardware_user_presence_required) return false
      if (user_verification_required != other.user_verification_required) return false
      return true
    }

    override fun hashCode(): Int {
      var result = super.hashCode
      if (result == 0) {
        result = unknownFields.hashCode()
        result = result * 37 + key_actions.hashCode()
        result = result * 37 + key_creation.hashCode()
        result = result * 37 + key_type.hashCode()
        result = result * 37 + (key_directive?.hashCode() ?: 0)
        result = result * 37 + key_app_directive.hashCode()
        result = result * 37 + key_storage_level.hashCode()
        result = result * 37 + hardware_user_presence_required.hashCode()
        result = result * 37 + user_verification_required.hashCode()
        super.hashCode = result
      }
      return result
    }

    override fun toString(): String {
      val result = mutableListOf<String>()
      if (key_actions.isNotEmpty()) result += """key_actions=$key_actions"""
      result += """key_creation=$key_creation"""
      result += """key_type=$key_type"""
      if (key_directive != null) result += """key_directive=$key_directive"""
      result += """key_app_directive=$key_app_directive"""
      result += """key_storage_level=$key_storage_level"""
      result += """hardware_user_presence_required=$hardware_user_presence_required"""
      result += """user_verification_required=$user_verification_required"""
      return result.joinToString(prefix = "SyncSingleKeyResponse{", separator = ", ", postfix = "}")
    }

    public fun copy(
      key_actions: List<KeyAction> = this.key_actions,
      key_creation: KeyCreation = this.key_creation,
      key_type: KeyType = this.key_type,
      key_directive: KeyDirective? = this.key_directive,
      key_app_directive: ByteString = this.key_app_directive,
      key_storage_level: KeyStorageLevel = this.key_storage_level,
      hardware_user_presence_required: Boolean = this.hardware_user_presence_required,
      user_verification_required: Boolean = this.user_verification_required,
      unknownFields: ByteString = this.unknownFields,
    ): SyncSingleKeyResponse = SyncSingleKeyResponse(key_actions, key_creation, key_type,
        key_directive, key_app_directive, key_storage_level, hardware_user_presence_required,
        user_verification_required, unknownFields)

    public class Builder : Message.Builder<SyncSingleKeyResponse, Builder>() {
      @JvmField
      public var key_actions: List<KeyAction> = emptyList()

      @JvmField
      public var key_creation: KeyCreation = KeyCreation.NONE

      @JvmField
      public var key_type: KeyType = KeyType.KEY_TYPE_UNSPECIFIED

      @JvmField
      public var key_directive: KeyDirective? = null

      @JvmField
      public var key_app_directive: ByteString = ByteString.EMPTY

      @JvmField
      public var key_storage_level: KeyStorageLevel = KeyStorageLevel.KEY_STORAGE_LEVEL_UNSPECIFIED

      @JvmField
      public var hardware_user_presence_required: Boolean = false

      @JvmField
      public var user_verification_required: Boolean = false

      /**
       * Key actions with one entry per key handle and in the same order as in the
       * request.
       */
      public fun key_actions(key_actions: List<KeyAction>): Builder {
        checkElementsNotNull(key_actions)
        this.key_actions = key_actions
        return this
      }

      /**
       * Instruction for key creation.
       */
      public fun key_creation(key_creation: KeyCreation): Builder {
        this.key_creation = key_creation
        return this
      }

      /**
       * The type of the cryptographic key.
       */
      public fun key_type(key_type: KeyType): Builder {
        this.key_type = key_type
        return this
      }

      /**
       * The updated key-specific directives.
       */
      public fun key_directive(key_directive: KeyDirective?): Builder {
        this.key_directive = key_directive
        return this
      }

      /**
       * A key-specific opaque blob given to the application.
       */
      public fun key_app_directive(key_app_directive: ByteString): Builder {
        this.key_app_directive = key_app_directive
        return this
      }

      /**
       * The storage level to create the key.
       */
      public fun key_storage_level(key_storage_level: KeyStorageLevel): Builder {
        this.key_storage_level = key_storage_level
        return this
      }

      /**
       * The newly created key should require hardware backed user presence when
       * using the key.
       */
      public fun hardware_user_presence_required(hardware_user_presence_required: Boolean):
          Builder {
        this.hardware_user_presence_required = hardware_user_presence_required
        return this
      }

      /**
       * The newly created key should require user verification when using the
       * key.
       */
      public fun user_verification_required(user_verification_required: Boolean): Builder {
        this.user_verification_required = user_verification_required
        return this
      }

      override fun build(): SyncSingleKeyResponse = SyncSingleKeyResponse(
        key_actions = key_actions,
        key_creation = key_creation,
        key_type = key_type,
        key_directive = key_directive,
        key_app_directive = key_app_directive,
        key_storage_level = key_storage_level,
        hardware_user_presence_required = hardware_user_presence_required,
        user_verification_required = user_verification_required,
        unknownFields = buildUnknownFields()
      )
    }

    public companion object {
      @JvmField
      public val ADAPTER: ProtoAdapter<SyncSingleKeyResponse> = object :
          ProtoAdapter<SyncSingleKeyResponse>(
        FieldEncoding.LENGTH_DELIMITED, 
        SyncSingleKeyResponse::class, 
        "type.googleapis.com/cryptauthv2.SyncKeysResponse.SyncSingleKeyResponse", 
        PROTO_3, 
        null, 
        "cryptauth/cryptauth_enrollment.proto"
      ) {
        override fun encodedSize(`value`: SyncSingleKeyResponse): Int {
          var size = value.unknownFields.size
          size += KeyAction.ADAPTER.asRepeated().encodedSizeWithTag(1, value.key_actions)
          if (value.key_creation != KeyCreation.NONE) size +=
              KeyCreation.ADAPTER.encodedSizeWithTag(2, value.key_creation)
          if (value.key_type != KeyType.KEY_TYPE_UNSPECIFIED) size +=
              KeyType.ADAPTER.encodedSizeWithTag(3, value.key_type)
          if (value.key_directive != null) size += KeyDirective.ADAPTER.encodedSizeWithTag(4,
              value.key_directive)
          if (value.key_app_directive != ByteString.EMPTY) size +=
              ProtoAdapter.BYTES.encodedSizeWithTag(5, value.key_app_directive)
          if (value.key_storage_level != KeyStorageLevel.KEY_STORAGE_LEVEL_UNSPECIFIED) size +=
              KeyStorageLevel.ADAPTER.encodedSizeWithTag(6, value.key_storage_level)
          if (value.hardware_user_presence_required != false) size +=
              ProtoAdapter.BOOL.encodedSizeWithTag(7, value.hardware_user_presence_required)
          if (value.user_verification_required != false) size +=
              ProtoAdapter.BOOL.encodedSizeWithTag(8, value.user_verification_required)
          return size
        }

        override fun encode(writer: ProtoWriter, `value`: SyncSingleKeyResponse) {
          KeyAction.ADAPTER.asRepeated().encodeWithTag(writer, 1, value.key_actions)
          if (value.key_creation != KeyCreation.NONE) KeyCreation.ADAPTER.encodeWithTag(writer, 2,
              value.key_creation)
          if (value.key_type != KeyType.KEY_TYPE_UNSPECIFIED) KeyType.ADAPTER.encodeWithTag(writer,
              3, value.key_type)
          if (value.key_directive != null) KeyDirective.ADAPTER.encodeWithTag(writer, 4,
              value.key_directive)
          if (value.key_app_directive != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer,
              5, value.key_app_directive)
          if (value.key_storage_level != KeyStorageLevel.KEY_STORAGE_LEVEL_UNSPECIFIED)
              KeyStorageLevel.ADAPTER.encodeWithTag(writer, 6, value.key_storage_level)
          if (value.hardware_user_presence_required != false)
              ProtoAdapter.BOOL.encodeWithTag(writer, 7, value.hardware_user_presence_required)
          if (value.user_verification_required != false) ProtoAdapter.BOOL.encodeWithTag(writer, 8,
              value.user_verification_required)
          writer.writeBytes(value.unknownFields)
        }

        override fun encode(writer: ReverseProtoWriter, `value`: SyncSingleKeyResponse) {
          writer.writeBytes(value.unknownFields)
          if (value.user_verification_required != false) ProtoAdapter.BOOL.encodeWithTag(writer, 8,
              value.user_verification_required)
          if (value.hardware_user_presence_required != false)
              ProtoAdapter.BOOL.encodeWithTag(writer, 7, value.hardware_user_presence_required)
          if (value.key_storage_level != KeyStorageLevel.KEY_STORAGE_LEVEL_UNSPECIFIED)
              KeyStorageLevel.ADAPTER.encodeWithTag(writer, 6, value.key_storage_level)
          if (value.key_app_directive != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer,
              5, value.key_app_directive)
          if (value.key_directive != null) KeyDirective.ADAPTER.encodeWithTag(writer, 4,
              value.key_directive)
          if (value.key_type != KeyType.KEY_TYPE_UNSPECIFIED) KeyType.ADAPTER.encodeWithTag(writer,
              3, value.key_type)
          if (value.key_creation != KeyCreation.NONE) KeyCreation.ADAPTER.encodeWithTag(writer, 2,
              value.key_creation)
          KeyAction.ADAPTER.asRepeated().encodeWithTag(writer, 1, value.key_actions)
        }

        override fun decode(reader: ProtoReader): SyncSingleKeyResponse {
          val key_actions = mutableListOf<KeyAction>()
          var key_creation: KeyCreation = KeyCreation.NONE
          var key_type: KeyType = KeyType.KEY_TYPE_UNSPECIFIED
          var key_directive: KeyDirective? = null
          var key_app_directive: ByteString = ByteString.EMPTY
          var key_storage_level: KeyStorageLevel = KeyStorageLevel.KEY_STORAGE_LEVEL_UNSPECIFIED
          var hardware_user_presence_required: Boolean = false
          var user_verification_required: Boolean = false
          val unknownFields = reader.forEachTag { tag ->
            when (tag) {
              1 -> try {
                KeyAction.ADAPTER.tryDecode(reader, key_actions)
              } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
                reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
              }
              2 -> try {
                key_creation = KeyCreation.ADAPTER.decode(reader)
              } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
                reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
              }
              3 -> try {
                key_type = KeyType.ADAPTER.decode(reader)
              } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
                reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
              }
              4 -> key_directive = KeyDirective.ADAPTER.decode(reader)
              5 -> key_app_directive = ProtoAdapter.BYTES.decode(reader)
              6 -> try {
                key_storage_level = KeyStorageLevel.ADAPTER.decode(reader)
              } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
                reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
              }
              7 -> hardware_user_presence_required = ProtoAdapter.BOOL.decode(reader)
              8 -> user_verification_required = ProtoAdapter.BOOL.decode(reader)
              else -> reader.readUnknownField(tag)
            }
          }
          return SyncSingleKeyResponse(
            key_actions = key_actions,
            key_creation = key_creation,
            key_type = key_type,
            key_directive = key_directive,
            key_app_directive = key_app_directive,
            key_storage_level = key_storage_level,
            hardware_user_presence_required = hardware_user_presence_required,
            user_verification_required = user_verification_required,
            unknownFields = unknownFields
          )
        }

        override fun redact(`value`: SyncSingleKeyResponse): SyncSingleKeyResponse = value.copy(
          key_directive = value.key_directive?.let(KeyDirective.ADAPTER::redact),
          unknownFields = ByteString.EMPTY
        )
      }

      private const val serialVersionUID: Long = 0L

      @JvmSynthetic
      public inline fun build(body: Builder.() -> Unit): SyncSingleKeyResponse =
          Builder().apply(body).build()
    }

    /**
     * The actions corresponding to the key handles in SyncKeysRequest.
     */
    public enum class KeyAction(
      override val `value`: Int,
    ) : WireEnum {
      /**
       * Default value. A client receiving this should treat it as a noop.
       * (-- But, be wary of b/119886258. --)
       */
      KEY_ACTION_UNSPECIFIED(0),
      /**
       * Keep the key and make it the "active" key.
       */
      ACTIVATE(1),
      /**
       * Keep the key. When enrollment is complete, ensure the key is not
       * "active".
       * (-- But, be wary of b/119886258 and a noop on iOS. --)
       */
      DEACTIVATE(2),
      /**
       * Delete the key.
       */
      DELETE(3),
      ;

      public companion object {
        @JvmField
        public val ADAPTER: ProtoAdapter<KeyAction> = object : EnumAdapter<KeyAction>(
          KeyAction::class, 
          PROTO_3, 
          KeyAction.KEY_ACTION_UNSPECIFIED
        ) {
          override fun fromValue(`value`: Int): KeyAction? = KeyAction.fromValue(`value`)
        }

        @JvmStatic
        public fun fromValue(`value`: Int): KeyAction? = when (`value`) {
          0 -> KEY_ACTION_UNSPECIFIED
          1 -> ACTIVATE
          2 -> DEACTIVATE
          3 -> DELETE
          else -> null
        }
      }
    }

    /**
     * The instruction for the client to create a new key.
     */
    public enum class KeyCreation(
      override val `value`: Int,
    ) : WireEnum {
      /**
       * Do not create a new key.
       */
      NONE(0),
      /**
       * Create a new key, and then use it as the "active" key.
       */
      ACTIVE(1),
      /**
       * Create a new key, but do not use it as the "active" key.
       * (-- Beware of b/119889101. This doesn't work on Android or iOS. --)
       */
      INACTIVE(2),
      ;

      public companion object {
        @JvmField
        public val ADAPTER: ProtoAdapter<KeyCreation> = object : EnumAdapter<KeyCreation>(
          KeyCreation::class, 
          PROTO_3, 
          KeyCreation.NONE
        ) {
          override fun fromValue(`value`: Int): KeyCreation? = KeyCreation.fromValue(`value`)
        }

        @JvmStatic
        public fun fromValue(`value`: Int): KeyCreation? = when (`value`) {
          0 -> NONE
          1 -> ACTIVE
          2 -> INACTIVE
          else -> null
        }
      }
    }

    /**
     * The storage level where the key is created and stored.
     */
    public enum class KeyStorageLevel(
      override val `value`: Int,
    ) : WireEnum {
      /**
       * Default value. The client is free to decide where to create the key.
       */
      KEY_STORAGE_LEVEL_UNSPECIFIED(0),
      /**
       * The key should be created and stored in software store. E.g. the
       * client may create a key using a crypto library and store it in a
       * file.
       */
      SOFTWARE(1),
      /**
       * The key should be created in a Trusted Execution Environment (TEE).
       * E.g., TrustZone from ARM chips.
       */
      TRUSTED_EXECUTION_ENVIRONMENT(2),
      /**
       * The key should be created in a dedicated hardware that is separate from
       * the main processor. E.g., StrongBox chips in Android devices and Secure
       * Enclave in iOS devices.
       */
      DEDICATED_SECURE_ELEMENT(3),
      ;

      public companion object {
        @JvmField
        public val ADAPTER: ProtoAdapter<KeyStorageLevel> = object : EnumAdapter<KeyStorageLevel>(
          KeyStorageLevel::class, 
          PROTO_3, 
          KeyStorageLevel.KEY_STORAGE_LEVEL_UNSPECIFIED
        ) {
          override fun fromValue(`value`: Int): KeyStorageLevel? =
              KeyStorageLevel.fromValue(`value`)
        }

        @JvmStatic
        public fun fromValue(`value`: Int): KeyStorageLevel? = when (`value`) {
          0 -> KEY_STORAGE_LEVEL_UNSPECIFIED
          1 -> SOFTWARE
          2 -> TRUSTED_EXECUTION_ENVIRONMENT
          3 -> DEDICATED_SECURE_ELEMENT
          else -> null
        }
      }
    }
  }

  /**
   * The state of the server.
   */
  public enum class ServerStatus(
    override val `value`: Int,
  ) : WireEnum {
    /**
     * The server is fine; the rest of SyncKeysResponse should be processed.
     */
    SERVER_OK(0),
    /**
     * The server is overloaded; client_directive should be followed.
     */
    SERVER_OVERLOADED(1),
    ;

    public companion object {
      @JvmField
      public val ADAPTER: ProtoAdapter<ServerStatus> = object : EnumAdapter<ServerStatus>(
        ServerStatus::class, 
        PROTO_3, 
        ServerStatus.SERVER_OK
      ) {
        override fun fromValue(`value`: Int): ServerStatus? = ServerStatus.fromValue(`value`)
      }

      @JvmStatic
      public fun fromValue(`value`: Int): ServerStatus? = when (`value`) {
        0 -> SERVER_OK
        1 -> SERVER_OVERLOADED
        else -> null
      }
    }
  }
}

// Code generated by Wire protocol buffer compiler, do not edit.
// Source: cryptauthv2.ClientMetadata in cryptauth/cryptauth_common.proto
@file:Suppress("DEPRECATION")

package cryptauthv2

import com.squareup.wire.EnumAdapter
import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.ReverseProtoWriter
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireEnum
import com.squareup.wire.WireField
import com.squareup.wire.`internal`.JvmField
import com.squareup.wire.`internal`.JvmStatic
import com.squareup.wire.`internal`.JvmSynthetic
import com.squareup.wire.`internal`.sanitize
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.Suppress
import kotlin.Unit
import okio.ByteString

/**
 * The client-specific metadata contained in SyncKeysRequest.
 *
 * Note: This message is encoded as query parameters for some requests. If any
 * field or subfield of this proto changes, update the files
 * cryptauth_proto_to_query_parameters_util.{h,cc}.
 */
public class ClientMetadata(
  /**
   * The counter for how many times the request has been retried.
   */
  @field:WireField(
    tag = 1,
    adapter = "com.squareup.wire.ProtoAdapter#INT64",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "retryCount",
    schemaIndex = 0,
  )
  @JvmField
  public val retry_count: Long = 0L,
  /**
   * Reason for invocation.
   */
  @field:WireField(
    tag = 2,
    adapter = "cryptauthv2.ClientMetadata${'$'}InvocationReason#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "invocationReason",
    schemaIndex = 1,
  )
  @JvmField
  public val invocation_reason: InvocationReason = InvocationReason.INVOCATION_REASON_UNSPECIFIED,
  /**
   * Crypto hardware available on the client.
   */
  @field:WireField(
    tag = 3,
    adapter = "cryptauthv2.ClientMetadata${'$'}CryptoHardware#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "cryptoHardware",
    schemaIndex = 2,
  )
  @JvmField
  public val crypto_hardware: CryptoHardware? = null,
  /**
   * If the request is issued as a direct result, or a follow-up for a
   * notification/tickle, the session_id from that notification.
   */
  @field:WireField(
    tag = 4,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "sessionId",
    schemaIndex = 3,
  )
  @JvmField
  public val session_id: String = "",
  unknownFields: ByteString = ByteString.EMPTY,
) : Message<ClientMetadata, ClientMetadata.Builder>(ADAPTER, unknownFields) {
  override fun newBuilder(): Builder {
    val builder = Builder()
    builder.retry_count = retry_count
    builder.invocation_reason = invocation_reason
    builder.crypto_hardware = crypto_hardware
    builder.session_id = session_id
    builder.addUnknownFields(unknownFields)
    return builder
  }

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is ClientMetadata) return false
    if (unknownFields != other.unknownFields) return false
    if (retry_count != other.retry_count) return false
    if (invocation_reason != other.invocation_reason) return false
    if (crypto_hardware != other.crypto_hardware) return false
    if (session_id != other.session_id) return false
    return true
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + retry_count.hashCode()
      result = result * 37 + invocation_reason.hashCode()
      result = result * 37 + (crypto_hardware?.hashCode() ?: 0)
      result = result * 37 + session_id.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    result += """retry_count=$retry_count"""
    result += """invocation_reason=$invocation_reason"""
    if (crypto_hardware != null) result += """crypto_hardware=$crypto_hardware"""
    result += """session_id=${sanitize(session_id)}"""
    return result.joinToString(prefix = "ClientMetadata{", separator = ", ", postfix = "}")
  }

  public fun copy(
    retry_count: Long = this.retry_count,
    invocation_reason: InvocationReason = this.invocation_reason,
    crypto_hardware: CryptoHardware? = this.crypto_hardware,
    session_id: String = this.session_id,
    unknownFields: ByteString = this.unknownFields,
  ): ClientMetadata = ClientMetadata(retry_count, invocation_reason, crypto_hardware, session_id,
      unknownFields)

  public class Builder : Message.Builder<ClientMetadata, Builder>() {
    @JvmField
    public var retry_count: Long = 0L

    @JvmField
    public var invocation_reason: InvocationReason = InvocationReason.INVOCATION_REASON_UNSPECIFIED

    @JvmField
    public var crypto_hardware: CryptoHardware? = null

    @JvmField
    public var session_id: String = ""

    /**
     * The counter for how many times the request has been retried.
     */
    public fun retry_count(retry_count: Long): Builder {
      this.retry_count = retry_count
      return this
    }

    /**
     * Reason for invocation.
     */
    public fun invocation_reason(invocation_reason: InvocationReason): Builder {
      this.invocation_reason = invocation_reason
      return this
    }

    /**
     * Crypto hardware available on the client.
     */
    public fun crypto_hardware(crypto_hardware: CryptoHardware?): Builder {
      this.crypto_hardware = crypto_hardware
      return this
    }

    /**
     * If the request is issued as a direct result, or a follow-up for a
     * notification/tickle, the session_id from that notification.
     */
    public fun session_id(session_id: String): Builder {
      this.session_id = session_id
      return this
    }

    override fun build(): ClientMetadata = ClientMetadata(
      retry_count = retry_count,
      invocation_reason = invocation_reason,
      crypto_hardware = crypto_hardware,
      session_id = session_id,
      unknownFields = buildUnknownFields()
    )
  }

  public companion object {
    @JvmField
    public val ADAPTER: ProtoAdapter<ClientMetadata> = object : ProtoAdapter<ClientMetadata>(
      FieldEncoding.LENGTH_DELIMITED, 
      ClientMetadata::class, 
      "type.googleapis.com/cryptauthv2.ClientMetadata", 
      PROTO_3, 
      null, 
      "cryptauth/cryptauth_common.proto"
    ) {
      override fun encodedSize(`value`: ClientMetadata): Int {
        var size = value.unknownFields.size
        if (value.retry_count != 0L) size += ProtoAdapter.INT64.encodedSizeWithTag(1,
            value.retry_count)
        if (value.invocation_reason != InvocationReason.INVOCATION_REASON_UNSPECIFIED) size +=
            InvocationReason.ADAPTER.encodedSizeWithTag(2, value.invocation_reason)
        if (value.crypto_hardware != null) size += CryptoHardware.ADAPTER.encodedSizeWithTag(3,
            value.crypto_hardware)
        if (value.session_id != "") size += ProtoAdapter.STRING.encodedSizeWithTag(4,
            value.session_id)
        return size
      }

      override fun encode(writer: ProtoWriter, `value`: ClientMetadata) {
        if (value.retry_count != 0L) ProtoAdapter.INT64.encodeWithTag(writer, 1, value.retry_count)
        if (value.invocation_reason != InvocationReason.INVOCATION_REASON_UNSPECIFIED)
            InvocationReason.ADAPTER.encodeWithTag(writer, 2, value.invocation_reason)
        if (value.crypto_hardware != null) CryptoHardware.ADAPTER.encodeWithTag(writer, 3,
            value.crypto_hardware)
        if (value.session_id != "") ProtoAdapter.STRING.encodeWithTag(writer, 4, value.session_id)
        writer.writeBytes(value.unknownFields)
      }

      override fun encode(writer: ReverseProtoWriter, `value`: ClientMetadata) {
        writer.writeBytes(value.unknownFields)
        if (value.session_id != "") ProtoAdapter.STRING.encodeWithTag(writer, 4, value.session_id)
        if (value.crypto_hardware != null) CryptoHardware.ADAPTER.encodeWithTag(writer, 3,
            value.crypto_hardware)
        if (value.invocation_reason != InvocationReason.INVOCATION_REASON_UNSPECIFIED)
            InvocationReason.ADAPTER.encodeWithTag(writer, 2, value.invocation_reason)
        if (value.retry_count != 0L) ProtoAdapter.INT64.encodeWithTag(writer, 1, value.retry_count)
      }

      override fun decode(reader: ProtoReader): ClientMetadata {
        var retry_count: Long = 0L
        var invocation_reason: InvocationReason = InvocationReason.INVOCATION_REASON_UNSPECIFIED
        var crypto_hardware: CryptoHardware? = null
        var session_id: String = ""
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> retry_count = ProtoAdapter.INT64.decode(reader)
            2 -> try {
              invocation_reason = InvocationReason.ADAPTER.decode(reader)
            } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
              reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
            }
            3 -> crypto_hardware = CryptoHardware.ADAPTER.decode(reader)
            4 -> session_id = ProtoAdapter.STRING.decode(reader)
            else -> reader.readUnknownField(tag)
          }
        }
        return ClientMetadata(
          retry_count = retry_count,
          invocation_reason = invocation_reason,
          crypto_hardware = crypto_hardware,
          session_id = session_id,
          unknownFields = unknownFields
        )
      }

      override fun redact(`value`: ClientMetadata): ClientMetadata = value.copy(
        crypto_hardware = value.crypto_hardware?.let(CryptoHardware.ADAPTER::redact),
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L

    @JvmSynthetic
    public inline fun build(body: Builder.() -> Unit): ClientMetadata =
        Builder().apply(body).build()
  }

  /**
   * The reason why the request has been invoked.
   */
  public enum class InvocationReason(
    override val `value`: Int,
  ) : WireEnum {
    /**
     * Unspecified invocation reason.
     */
    INVOCATION_REASON_UNSPECIFIED(0),
    /**
     * First run of the software package invoking this call.
     */
    INITIALIZATION(1),
    /**
     * Ordinary periodic actions (e.g., monthly key rotation).
     */
    PERIODIC(2),
    /**
     * Slow-cycle periodic action (e.g., yearly keypair rotation).
     */
    SLOW_PERIODIC(3),
    /**
     * Fast-cycle periodic action (e.g., daily sync for Smart Lock users).
     */
    FAST_PERIODIC(4),
    /**
     * Expired state (e.g., expired credentials, or cached entries) was
     * detected.
     */
    EXPIRATION(5),
    /**
     * An unexpected protocol failure occurred (so attempting to repair state).
     */
    FAILURE_RECOVERY(6),
    /**
     * A new account has been added to the device.
     */
    NEW_ACCOUNT(7),
    /**
     * An existing account on the device has been changed.
     */
    CHANGED_ACCOUNT(8),
    /**
     * The user toggled the state of a feature (e.g., Smart Lock enabled via
     * bluetooth).
     */
    FEATURE_TOGGLED(9),
    /**
     * A "push" from the server caused this action (e.g., a sync tickle).
     */
    SERVER_INITIATED(10),
    /**
     * A local address change triggered this (e.g., GCM registration id
     * changed).
     */
    ADDRESS_CHANGE(11),
    /**
     * A software update has triggered this.
     */
    SOFTWARE_UPDATE(12),
    /**
     * A manual action by the user triggered this (e.g., commands sent via adb).
     */
    MANUAL(13),
    /**
     * A custom key has been invalidated on the device (e.g. screen lock is
     * disabled).
     */
    CUSTOM_KEY_INVALIDATION(14),
    /**
     * Periodic action triggered by auth_proximity
     */
    PROXIMITY_PERIODIC(15),
    ;

    public companion object {
      @JvmField
      public val ADAPTER: ProtoAdapter<InvocationReason> = object : EnumAdapter<InvocationReason>(
        InvocationReason::class, 
        PROTO_3, 
        InvocationReason.INVOCATION_REASON_UNSPECIFIED
      ) {
        override fun fromValue(`value`: Int): InvocationReason? =
            InvocationReason.fromValue(`value`)
      }

      @JvmStatic
      public fun fromValue(`value`: Int): InvocationReason? = when (`value`) {
        0 -> INVOCATION_REASON_UNSPECIFIED
        1 -> INITIALIZATION
        2 -> PERIODIC
        3 -> SLOW_PERIODIC
        4 -> FAST_PERIODIC
        5 -> EXPIRATION
        6 -> FAILURE_RECOVERY
        7 -> NEW_ACCOUNT
        8 -> CHANGED_ACCOUNT
        9 -> FEATURE_TOGGLED
        10 -> SERVER_INITIATED
        11 -> ADDRESS_CHANGE
        12 -> SOFTWARE_UPDATE
        13 -> MANUAL
        14 -> CUSTOM_KEY_INVALIDATION
        15 -> PROXIMITY_PERIODIC
        else -> null
      }
    }
  }

  /**
   * Whether the platform has hardware supports for certain algorithms.
   */
  public class CryptoHardware(
    /**
     * AES-128
     */
    @field:WireField(
      tag = 1,
      adapter = "com.squareup.wire.ProtoAdapter#BOOL",
      label = WireField.Label.OMIT_IDENTITY,
      schemaIndex = 0,
    )
    @JvmField
    public val aes128: Boolean = false,
    /**
     * ASE-256
     */
    @field:WireField(
      tag = 2,
      adapter = "com.squareup.wire.ProtoAdapter#BOOL",
      label = WireField.Label.OMIT_IDENTITY,
      schemaIndex = 1,
    )
    @JvmField
    public val aes256: Boolean = false,
    /**
     * Carryless multiplication
     */
    @field:WireField(
      tag = 3,
      adapter = "com.squareup.wire.ProtoAdapter#BOOL",
      label = WireField.Label.OMIT_IDENTITY,
      schemaIndex = 2,
    )
    @JvmField
    public val clmul: Boolean = false,
    /**
     * Curve25519
     */
    @field:WireField(
      tag = 4,
      adapter = "com.squareup.wire.ProtoAdapter#BOOL",
      label = WireField.Label.OMIT_IDENTITY,
      schemaIndex = 3,
    )
    @JvmField
    public val curve25519: Boolean = false,
    /**
     * P256
     */
    @field:WireField(
      tag = 5,
      adapter = "com.squareup.wire.ProtoAdapter#BOOL",
      label = WireField.Label.OMIT_IDENTITY,
      schemaIndex = 4,
    )
    @JvmField
    public val p256: Boolean = false,
    unknownFields: ByteString = ByteString.EMPTY,
  ) : Message<CryptoHardware, CryptoHardware.Builder>(ADAPTER, unknownFields) {
    override fun newBuilder(): Builder {
      val builder = Builder()
      builder.aes128 = aes128
      builder.aes256 = aes256
      builder.clmul = clmul
      builder.curve25519 = curve25519
      builder.p256 = p256
      builder.addUnknownFields(unknownFields)
      return builder
    }

    override fun equals(other: Any?): Boolean {
      if (other === this) return true
      if (other !is CryptoHardware) return false
      if (unknownFields != other.unknownFields) return false
      if (aes128 != other.aes128) return false
      if (aes256 != other.aes256) return false
      if (clmul != other.clmul) return false
      if (curve25519 != other.curve25519) return false
      if (p256 != other.p256) return false
      return true
    }

    override fun hashCode(): Int {
      var result = super.hashCode
      if (result == 0) {
        result = unknownFields.hashCode()
        result = result * 37 + aes128.hashCode()
        result = result * 37 + aes256.hashCode()
        result = result * 37 + clmul.hashCode()
        result = result * 37 + curve25519.hashCode()
        result = result * 37 + p256.hashCode()
        super.hashCode = result
      }
      return result
    }

    override fun toString(): String {
      val result = mutableListOf<String>()
      result += """aes128=$aes128"""
      result += """aes256=$aes256"""
      result += """clmul=$clmul"""
      result += """curve25519=$curve25519"""
      result += """p256=$p256"""
      return result.joinToString(prefix = "CryptoHardware{", separator = ", ", postfix = "}")
    }

    public fun copy(
      aes128: Boolean = this.aes128,
      aes256: Boolean = this.aes256,
      clmul: Boolean = this.clmul,
      curve25519: Boolean = this.curve25519,
      p256: Boolean = this.p256,
      unknownFields: ByteString = this.unknownFields,
    ): CryptoHardware = CryptoHardware(aes128, aes256, clmul, curve25519, p256, unknownFields)

    public class Builder : Message.Builder<CryptoHardware, Builder>() {
      @JvmField
      public var aes128: Boolean = false

      @JvmField
      public var aes256: Boolean = false

      @JvmField
      public var clmul: Boolean = false

      @JvmField
      public var curve25519: Boolean = false

      @JvmField
      public var p256: Boolean = false

      /**
       * AES-128
       */
      public fun aes128(aes128: Boolean): Builder {
        this.aes128 = aes128
        return this
      }

      /**
       * ASE-256
       */
      public fun aes256(aes256: Boolean): Builder {
        this.aes256 = aes256
        return this
      }

      /**
       * Carryless multiplication
       */
      public fun clmul(clmul: Boolean): Builder {
        this.clmul = clmul
        return this
      }

      /**
       * Curve25519
       */
      public fun curve25519(curve25519: Boolean): Builder {
        this.curve25519 = curve25519
        return this
      }

      /**
       * P256
       */
      public fun p256(p256: Boolean): Builder {
        this.p256 = p256
        return this
      }

      override fun build(): CryptoHardware = CryptoHardware(
        aes128 = aes128,
        aes256 = aes256,
        clmul = clmul,
        curve25519 = curve25519,
        p256 = p256,
        unknownFields = buildUnknownFields()
      )
    }

    public companion object {
      @JvmField
      public val ADAPTER: ProtoAdapter<CryptoHardware> = object : ProtoAdapter<CryptoHardware>(
        FieldEncoding.LENGTH_DELIMITED, 
        CryptoHardware::class, 
        "type.googleapis.com/cryptauthv2.ClientMetadata.CryptoHardware", 
        PROTO_3, 
        null, 
        "cryptauth/cryptauth_common.proto"
      ) {
        override fun encodedSize(`value`: CryptoHardware): Int {
          var size = value.unknownFields.size
          if (value.aes128 != false) size += ProtoAdapter.BOOL.encodedSizeWithTag(1, value.aes128)
          if (value.aes256 != false) size += ProtoAdapter.BOOL.encodedSizeWithTag(2, value.aes256)
          if (value.clmul != false) size += ProtoAdapter.BOOL.encodedSizeWithTag(3, value.clmul)
          if (value.curve25519 != false) size += ProtoAdapter.BOOL.encodedSizeWithTag(4,
              value.curve25519)
          if (value.p256 != false) size += ProtoAdapter.BOOL.encodedSizeWithTag(5, value.p256)
          return size
        }

        override fun encode(writer: ProtoWriter, `value`: CryptoHardware) {
          if (value.aes128 != false) ProtoAdapter.BOOL.encodeWithTag(writer, 1, value.aes128)
          if (value.aes256 != false) ProtoAdapter.BOOL.encodeWithTag(writer, 2, value.aes256)
          if (value.clmul != false) ProtoAdapter.BOOL.encodeWithTag(writer, 3, value.clmul)
          if (value.curve25519 != false) ProtoAdapter.BOOL.encodeWithTag(writer, 4,
              value.curve25519)
          if (value.p256 != false) ProtoAdapter.BOOL.encodeWithTag(writer, 5, value.p256)
          writer.writeBytes(value.unknownFields)
        }

        override fun encode(writer: ReverseProtoWriter, `value`: CryptoHardware) {
          writer.writeBytes(value.unknownFields)
          if (value.p256 != false) ProtoAdapter.BOOL.encodeWithTag(writer, 5, value.p256)
          if (value.curve25519 != false) ProtoAdapter.BOOL.encodeWithTag(writer, 4,
              value.curve25519)
          if (value.clmul != false) ProtoAdapter.BOOL.encodeWithTag(writer, 3, value.clmul)
          if (value.aes256 != false) ProtoAdapter.BOOL.encodeWithTag(writer, 2, value.aes256)
          if (value.aes128 != false) ProtoAdapter.BOOL.encodeWithTag(writer, 1, value.aes128)
        }

        override fun decode(reader: ProtoReader): CryptoHardware {
          var aes128: Boolean = false
          var aes256: Boolean = false
          var clmul: Boolean = false
          var curve25519: Boolean = false
          var p256: Boolean = false
          val unknownFields = reader.forEachTag { tag ->
            when (tag) {
              1 -> aes128 = ProtoAdapter.BOOL.decode(reader)
              2 -> aes256 = ProtoAdapter.BOOL.decode(reader)
              3 -> clmul = ProtoAdapter.BOOL.decode(reader)
              4 -> curve25519 = ProtoAdapter.BOOL.decode(reader)
              5 -> p256 = ProtoAdapter.BOOL.decode(reader)
              else -> reader.readUnknownField(tag)
            }
          }
          return CryptoHardware(
            aes128 = aes128,
            aes256 = aes256,
            clmul = clmul,
            curve25519 = curve25519,
            p256 = p256,
            unknownFields = unknownFields
          )
        }

        override fun redact(`value`: CryptoHardware): CryptoHardware = value.copy(
          unknownFields = ByteString.EMPTY
        )
      }

      private const val serialVersionUID: Long = 0L

      @JvmSynthetic
      public inline fun build(body: Builder.() -> Unit): CryptoHardware =
          Builder().apply(body).build()
    }
  }
}

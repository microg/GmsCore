// Code generated by Wire protocol buffer compiler, do not edit.
// Source: cryptauthv2.EnrollKeysRequest in cryptauth/cryptauth_enrollment.proto
@file:Suppress("DEPRECATION")

package cryptauthv2

import com.squareup.wire.EnumAdapter
import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.ReverseProtoWriter
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireEnum
import com.squareup.wire.WireField
import com.squareup.wire.`internal`.JvmField
import com.squareup.wire.`internal`.JvmStatic
import com.squareup.wire.`internal`.JvmSynthetic
import com.squareup.wire.`internal`.checkElementsNotNull
import com.squareup.wire.`internal`.immutableCopyOf
import com.squareup.wire.`internal`.redactElements
import com.squareup.wire.`internal`.sanitize
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.Suppress
import kotlin.Unit
import kotlin.collections.List
import okio.ByteString

/**
 * The second request in the enrollment protocol. The second request is
 * necessary if the client wants to enroll a new key. The request contains the
 * information such as the material of the new key, and necessary proofs for
 * verifying the key.
 */
public class EnrollKeysRequest(
  /**
   * The session identifier copied from the SyncKeysResponse message.
   */
  @field:WireField(
    tag = 1,
    adapter = "com.squareup.wire.ProtoAdapter#BYTES",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "randomSessionId",
    schemaIndex = 0,
  )
  @JvmField
  public val random_session_id: ByteString = ByteString.EMPTY,
  /**
   * The ephemeral DH public key generated by the client.
   */
  @field:WireField(
    tag = 2,
    adapter = "com.squareup.wire.ProtoAdapter#BYTES",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "clientEphemeralDh",
    schemaIndex = 1,
  )
  @JvmField
  public val client_ephemeral_dh: ByteString = ByteString.EMPTY,
  enroll_single_key_requests: List<EnrollSingleKeyRequest> = emptyList(),
  unknownFields: ByteString = ByteString.EMPTY,
) : Message<EnrollKeysRequest, EnrollKeysRequest.Builder>(ADAPTER, unknownFields) {
  /**
   * Per key enroll data.
   */
  @field:WireField(
    tag = 3,
    adapter = "cryptauthv2.EnrollKeysRequest${'$'}EnrollSingleKeyRequest#ADAPTER",
    label = WireField.Label.REPEATED,
    jsonName = "enrollSingleKeyRequests",
    schemaIndex = 2,
  )
  @JvmField
  public val enroll_single_key_requests: List<EnrollSingleKeyRequest> =
      immutableCopyOf("enroll_single_key_requests", enroll_single_key_requests)

  override fun newBuilder(): Builder {
    val builder = Builder()
    builder.random_session_id = random_session_id
    builder.client_ephemeral_dh = client_ephemeral_dh
    builder.enroll_single_key_requests = enroll_single_key_requests
    builder.addUnknownFields(unknownFields)
    return builder
  }

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is EnrollKeysRequest) return false
    if (unknownFields != other.unknownFields) return false
    if (random_session_id != other.random_session_id) return false
    if (client_ephemeral_dh != other.client_ephemeral_dh) return false
    if (enroll_single_key_requests != other.enroll_single_key_requests) return false
    return true
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + random_session_id.hashCode()
      result = result * 37 + client_ephemeral_dh.hashCode()
      result = result * 37 + enroll_single_key_requests.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    result += """random_session_id=$random_session_id"""
    result += """client_ephemeral_dh=$client_ephemeral_dh"""
    if (enroll_single_key_requests.isNotEmpty()) result +=
        """enroll_single_key_requests=$enroll_single_key_requests"""
    return result.joinToString(prefix = "EnrollKeysRequest{", separator = ", ", postfix = "}")
  }

  public fun copy(
    random_session_id: ByteString = this.random_session_id,
    client_ephemeral_dh: ByteString = this.client_ephemeral_dh,
    enroll_single_key_requests: List<EnrollSingleKeyRequest> = this.enroll_single_key_requests,
    unknownFields: ByteString = this.unknownFields,
  ): EnrollKeysRequest = EnrollKeysRequest(random_session_id, client_ephemeral_dh,
      enroll_single_key_requests, unknownFields)

  public class Builder : Message.Builder<EnrollKeysRequest, Builder>() {
    @JvmField
    public var random_session_id: ByteString = ByteString.EMPTY

    @JvmField
    public var client_ephemeral_dh: ByteString = ByteString.EMPTY

    @JvmField
    public var enroll_single_key_requests: List<EnrollSingleKeyRequest> = emptyList()

    /**
     * The session identifier copied from the SyncKeysResponse message.
     */
    public fun random_session_id(random_session_id: ByteString): Builder {
      this.random_session_id = random_session_id
      return this
    }

    /**
     * The ephemeral DH public key generated by the client.
     */
    public fun client_ephemeral_dh(client_ephemeral_dh: ByteString): Builder {
      this.client_ephemeral_dh = client_ephemeral_dh
      return this
    }

    /**
     * Per key enroll data.
     */
    public fun enroll_single_key_requests(enroll_single_key_requests: List<EnrollSingleKeyRequest>):
        Builder {
      checkElementsNotNull(enroll_single_key_requests)
      this.enroll_single_key_requests = enroll_single_key_requests
      return this
    }

    override fun build(): EnrollKeysRequest = EnrollKeysRequest(
      random_session_id = random_session_id,
      client_ephemeral_dh = client_ephemeral_dh,
      enroll_single_key_requests = enroll_single_key_requests,
      unknownFields = buildUnknownFields()
    )
  }

  public companion object {
    @JvmField
    public val ADAPTER: ProtoAdapter<EnrollKeysRequest> = object : ProtoAdapter<EnrollKeysRequest>(
      FieldEncoding.LENGTH_DELIMITED, 
      EnrollKeysRequest::class, 
      "type.googleapis.com/cryptauthv2.EnrollKeysRequest", 
      PROTO_3, 
      null, 
      "cryptauth/cryptauth_enrollment.proto"
    ) {
      override fun encodedSize(`value`: EnrollKeysRequest): Int {
        var size = value.unknownFields.size
        if (value.random_session_id != ByteString.EMPTY) size +=
            ProtoAdapter.BYTES.encodedSizeWithTag(1, value.random_session_id)
        if (value.client_ephemeral_dh != ByteString.EMPTY) size +=
            ProtoAdapter.BYTES.encodedSizeWithTag(2, value.client_ephemeral_dh)
        size += EnrollSingleKeyRequest.ADAPTER.asRepeated().encodedSizeWithTag(3,
            value.enroll_single_key_requests)
        return size
      }

      override fun encode(writer: ProtoWriter, `value`: EnrollKeysRequest) {
        if (value.random_session_id != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer, 1,
            value.random_session_id)
        if (value.client_ephemeral_dh != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer,
            2, value.client_ephemeral_dh)
        EnrollSingleKeyRequest.ADAPTER.asRepeated().encodeWithTag(writer, 3,
            value.enroll_single_key_requests)
        writer.writeBytes(value.unknownFields)
      }

      override fun encode(writer: ReverseProtoWriter, `value`: EnrollKeysRequest) {
        writer.writeBytes(value.unknownFields)
        EnrollSingleKeyRequest.ADAPTER.asRepeated().encodeWithTag(writer, 3,
            value.enroll_single_key_requests)
        if (value.client_ephemeral_dh != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer,
            2, value.client_ephemeral_dh)
        if (value.random_session_id != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer, 1,
            value.random_session_id)
      }

      override fun decode(reader: ProtoReader): EnrollKeysRequest {
        var random_session_id: ByteString = ByteString.EMPTY
        var client_ephemeral_dh: ByteString = ByteString.EMPTY
        val enroll_single_key_requests = mutableListOf<EnrollSingleKeyRequest>()
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> random_session_id = ProtoAdapter.BYTES.decode(reader)
            2 -> client_ephemeral_dh = ProtoAdapter.BYTES.decode(reader)
            3 -> enroll_single_key_requests.add(EnrollSingleKeyRequest.ADAPTER.decode(reader))
            else -> reader.readUnknownField(tag)
          }
        }
        return EnrollKeysRequest(
          random_session_id = random_session_id,
          client_ephemeral_dh = client_ephemeral_dh,
          enroll_single_key_requests = enroll_single_key_requests,
          unknownFields = unknownFields
        )
      }

      override fun redact(`value`: EnrollKeysRequest): EnrollKeysRequest = value.copy(
        enroll_single_key_requests =
            value.enroll_single_key_requests.redactElements(EnrollSingleKeyRequest.ADAPTER),
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L

    @JvmSynthetic
    public inline fun build(body: Builder.() -> Unit): EnrollKeysRequest =
        Builder().apply(body).build()
  }

  /**
   * The request to enroll a key, e.g., create a new key or rotate an old one.
   */
  public class EnrollSingleKeyRequest(
    /**
     * The key_name copied from SyncKeysRequest.
     */
    @field:WireField(
      tag = 1,
      adapter = "com.squareup.wire.ProtoAdapter#STRING",
      label = WireField.Label.OMIT_IDENTITY,
      jsonName = "keyName",
      schemaIndex = 0,
    )
    @JvmField
    public val key_name: String = "",
    /**
     * The identifier of the new key.
     */
    @field:WireField(
      tag = 2,
      adapter = "com.squareup.wire.ProtoAdapter#BYTES",
      label = WireField.Label.OMIT_IDENTITY,
      jsonName = "newKeyHandle",
      schemaIndex = 1,
    )
    @JvmField
    public val new_key_handle: ByteString = ByteString.EMPTY,
    /**
     * The raw bytes of the new public key or custom data.
     */
    @field:WireField(
      tag = 3,
      adapter = "com.squareup.wire.ProtoAdapter#BYTES",
      label = WireField.Label.OMIT_IDENTITY,
      jsonName = "keyMaterial",
      schemaIndex = 2,
    )
    @JvmField
    public val key_material: ByteString = ByteString.EMPTY,
    /**
     * The public-key signature or MAC tag that shows the client indeed
     * possesses the private or secret key.
     */
    @field:WireField(
      tag = 4,
      adapter = "com.squareup.wire.ProtoAdapter#BYTES",
      label = WireField.Label.OMIT_IDENTITY,
      jsonName = "keyProof",
      schemaIndex = 3,
    )
    @JvmField
    public val key_proof: ByteString = ByteString.EMPTY,
    key_crossproofs: List<KeyCrossproof> = emptyList(),
    certificate_requests: List<CertificateRequest> = emptyList(),
    /**
     * The attestation of the key if the key supports one.
     */
    @field:WireField(
      tag = 7,
      adapter =
          "cryptauthv2.EnrollKeysRequest${'$'}EnrollSingleKeyRequest${'$'}KeyAttestation#ADAPTER",
      label = WireField.Label.OMIT_IDENTITY,
      jsonName = "keyAttestation",
      schemaIndex = 6,
    )
    @JvmField
    public val key_attestation: KeyAttestation? = null,
    unknownFields: ByteString = ByteString.EMPTY,
  ) : Message<EnrollSingleKeyRequest, EnrollSingleKeyRequest.Builder>(ADAPTER, unknownFields) {
    /**
     * Cross proofs.
     */
    @field:WireField(
      tag = 5,
      adapter =
          "cryptauthv2.EnrollKeysRequest${'$'}EnrollSingleKeyRequest${'$'}KeyCrossproof#ADAPTER",
      label = WireField.Label.REPEATED,
      jsonName = "keyCrossproofs",
      schemaIndex = 4,
    )
    @JvmField
    public val key_crossproofs: List<KeyCrossproof> = immutableCopyOf("key_crossproofs",
        key_crossproofs)

    /**
     * Subject to certify.
     */
    @field:WireField(
      tag = 6,
      adapter = "cryptauthv2.CertificateRequest#ADAPTER",
      label = WireField.Label.REPEATED,
      jsonName = "certificateRequests",
      schemaIndex = 5,
    )
    @JvmField
    public val certificate_requests: List<CertificateRequest> =
        immutableCopyOf("certificate_requests", certificate_requests)

    override fun newBuilder(): Builder {
      val builder = Builder()
      builder.key_name = key_name
      builder.new_key_handle = new_key_handle
      builder.key_material = key_material
      builder.key_proof = key_proof
      builder.key_crossproofs = key_crossproofs
      builder.certificate_requests = certificate_requests
      builder.key_attestation = key_attestation
      builder.addUnknownFields(unknownFields)
      return builder
    }

    override fun equals(other: Any?): Boolean {
      if (other === this) return true
      if (other !is EnrollSingleKeyRequest) return false
      if (unknownFields != other.unknownFields) return false
      if (key_name != other.key_name) return false
      if (new_key_handle != other.new_key_handle) return false
      if (key_material != other.key_material) return false
      if (key_proof != other.key_proof) return false
      if (key_crossproofs != other.key_crossproofs) return false
      if (certificate_requests != other.certificate_requests) return false
      if (key_attestation != other.key_attestation) return false
      return true
    }

    override fun hashCode(): Int {
      var result = super.hashCode
      if (result == 0) {
        result = unknownFields.hashCode()
        result = result * 37 + key_name.hashCode()
        result = result * 37 + new_key_handle.hashCode()
        result = result * 37 + key_material.hashCode()
        result = result * 37 + key_proof.hashCode()
        result = result * 37 + key_crossproofs.hashCode()
        result = result * 37 + certificate_requests.hashCode()
        result = result * 37 + (key_attestation?.hashCode() ?: 0)
        super.hashCode = result
      }
      return result
    }

    override fun toString(): String {
      val result = mutableListOf<String>()
      result += """key_name=${sanitize(key_name)}"""
      result += """new_key_handle=$new_key_handle"""
      result += """key_material=$key_material"""
      result += """key_proof=$key_proof"""
      if (key_crossproofs.isNotEmpty()) result += """key_crossproofs=$key_crossproofs"""
      if (certificate_requests.isNotEmpty()) result +=
          """certificate_requests=$certificate_requests"""
      if (key_attestation != null) result += """key_attestation=$key_attestation"""
      return result.joinToString(prefix = "EnrollSingleKeyRequest{", separator = ", ", postfix =
          "}")
    }

    public fun copy(
      key_name: String = this.key_name,
      new_key_handle: ByteString = this.new_key_handle,
      key_material: ByteString = this.key_material,
      key_proof: ByteString = this.key_proof,
      key_crossproofs: List<KeyCrossproof> = this.key_crossproofs,
      certificate_requests: List<CertificateRequest> = this.certificate_requests,
      key_attestation: KeyAttestation? = this.key_attestation,
      unknownFields: ByteString = this.unknownFields,
    ): EnrollSingleKeyRequest = EnrollSingleKeyRequest(key_name, new_key_handle, key_material,
        key_proof, key_crossproofs, certificate_requests, key_attestation, unknownFields)

    public class Builder : Message.Builder<EnrollSingleKeyRequest, Builder>() {
      @JvmField
      public var key_name: String = ""

      @JvmField
      public var new_key_handle: ByteString = ByteString.EMPTY

      @JvmField
      public var key_material: ByteString = ByteString.EMPTY

      @JvmField
      public var key_proof: ByteString = ByteString.EMPTY

      @JvmField
      public var key_crossproofs: List<KeyCrossproof> = emptyList()

      @JvmField
      public var certificate_requests: List<CertificateRequest> = emptyList()

      @JvmField
      public var key_attestation: KeyAttestation? = null

      /**
       * The key_name copied from SyncKeysRequest.
       */
      public fun key_name(key_name: String): Builder {
        this.key_name = key_name
        return this
      }

      /**
       * The identifier of the new key.
       */
      public fun new_key_handle(new_key_handle: ByteString): Builder {
        this.new_key_handle = new_key_handle
        return this
      }

      /**
       * The raw bytes of the new public key or custom data.
       */
      public fun key_material(key_material: ByteString): Builder {
        this.key_material = key_material
        return this
      }

      /**
       * The public-key signature or MAC tag that shows the client indeed
       * possesses the private or secret key.
       */
      public fun key_proof(key_proof: ByteString): Builder {
        this.key_proof = key_proof
        return this
      }

      /**
       * Cross proofs.
       */
      public fun key_crossproofs(key_crossproofs: List<KeyCrossproof>): Builder {
        checkElementsNotNull(key_crossproofs)
        this.key_crossproofs = key_crossproofs
        return this
      }

      /**
       * Subject to certify.
       */
      public fun certificate_requests(certificate_requests: List<CertificateRequest>): Builder {
        checkElementsNotNull(certificate_requests)
        this.certificate_requests = certificate_requests
        return this
      }

      /**
       * The attestation of the key if the key supports one.
       */
      public fun key_attestation(key_attestation: KeyAttestation?): Builder {
        this.key_attestation = key_attestation
        return this
      }

      override fun build(): EnrollSingleKeyRequest = EnrollSingleKeyRequest(
        key_name = key_name,
        new_key_handle = new_key_handle,
        key_material = key_material,
        key_proof = key_proof,
        key_crossproofs = key_crossproofs,
        certificate_requests = certificate_requests,
        key_attestation = key_attestation,
        unknownFields = buildUnknownFields()
      )
    }

    public companion object {
      @JvmField
      public val ADAPTER: ProtoAdapter<EnrollSingleKeyRequest> = object :
          ProtoAdapter<EnrollSingleKeyRequest>(
        FieldEncoding.LENGTH_DELIMITED, 
        EnrollSingleKeyRequest::class, 
        "type.googleapis.com/cryptauthv2.EnrollKeysRequest.EnrollSingleKeyRequest", 
        PROTO_3, 
        null, 
        "cryptauth/cryptauth_enrollment.proto"
      ) {
        override fun encodedSize(`value`: EnrollSingleKeyRequest): Int {
          var size = value.unknownFields.size
          if (value.key_name != "") size += ProtoAdapter.STRING.encodedSizeWithTag(1,
              value.key_name)
          if (value.new_key_handle != ByteString.EMPTY) size +=
              ProtoAdapter.BYTES.encodedSizeWithTag(2, value.new_key_handle)
          if (value.key_material != ByteString.EMPTY) size +=
              ProtoAdapter.BYTES.encodedSizeWithTag(3, value.key_material)
          if (value.key_proof != ByteString.EMPTY) size += ProtoAdapter.BYTES.encodedSizeWithTag(4,
              value.key_proof)
          size += KeyCrossproof.ADAPTER.asRepeated().encodedSizeWithTag(5, value.key_crossproofs)
          size += CertificateRequest.ADAPTER.asRepeated().encodedSizeWithTag(6,
              value.certificate_requests)
          if (value.key_attestation != null) size += KeyAttestation.ADAPTER.encodedSizeWithTag(7,
              value.key_attestation)
          return size
        }

        override fun encode(writer: ProtoWriter, `value`: EnrollSingleKeyRequest) {
          if (value.key_name != "") ProtoAdapter.STRING.encodeWithTag(writer, 1, value.key_name)
          if (value.new_key_handle != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer, 2,
              value.new_key_handle)
          if (value.key_material != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer, 3,
              value.key_material)
          if (value.key_proof != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer, 4,
              value.key_proof)
          KeyCrossproof.ADAPTER.asRepeated().encodeWithTag(writer, 5, value.key_crossproofs)
          CertificateRequest.ADAPTER.asRepeated().encodeWithTag(writer, 6,
              value.certificate_requests)
          if (value.key_attestation != null) KeyAttestation.ADAPTER.encodeWithTag(writer, 7,
              value.key_attestation)
          writer.writeBytes(value.unknownFields)
        }

        override fun encode(writer: ReverseProtoWriter, `value`: EnrollSingleKeyRequest) {
          writer.writeBytes(value.unknownFields)
          if (value.key_attestation != null) KeyAttestation.ADAPTER.encodeWithTag(writer, 7,
              value.key_attestation)
          CertificateRequest.ADAPTER.asRepeated().encodeWithTag(writer, 6,
              value.certificate_requests)
          KeyCrossproof.ADAPTER.asRepeated().encodeWithTag(writer, 5, value.key_crossproofs)
          if (value.key_proof != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer, 4,
              value.key_proof)
          if (value.key_material != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer, 3,
              value.key_material)
          if (value.new_key_handle != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer, 2,
              value.new_key_handle)
          if (value.key_name != "") ProtoAdapter.STRING.encodeWithTag(writer, 1, value.key_name)
        }

        override fun decode(reader: ProtoReader): EnrollSingleKeyRequest {
          var key_name: String = ""
          var new_key_handle: ByteString = ByteString.EMPTY
          var key_material: ByteString = ByteString.EMPTY
          var key_proof: ByteString = ByteString.EMPTY
          val key_crossproofs = mutableListOf<KeyCrossproof>()
          val certificate_requests = mutableListOf<CertificateRequest>()
          var key_attestation: KeyAttestation? = null
          val unknownFields = reader.forEachTag { tag ->
            when (tag) {
              1 -> key_name = ProtoAdapter.STRING.decode(reader)
              2 -> new_key_handle = ProtoAdapter.BYTES.decode(reader)
              3 -> key_material = ProtoAdapter.BYTES.decode(reader)
              4 -> key_proof = ProtoAdapter.BYTES.decode(reader)
              5 -> key_crossproofs.add(KeyCrossproof.ADAPTER.decode(reader))
              6 -> certificate_requests.add(CertificateRequest.ADAPTER.decode(reader))
              7 -> key_attestation = KeyAttestation.ADAPTER.decode(reader)
              else -> reader.readUnknownField(tag)
            }
          }
          return EnrollSingleKeyRequest(
            key_name = key_name,
            new_key_handle = new_key_handle,
            key_material = key_material,
            key_proof = key_proof,
            key_crossproofs = key_crossproofs,
            certificate_requests = certificate_requests,
            key_attestation = key_attestation,
            unknownFields = unknownFields
          )
        }

        override fun redact(`value`: EnrollSingleKeyRequest): EnrollSingleKeyRequest = value.copy(
          key_crossproofs = value.key_crossproofs.redactElements(KeyCrossproof.ADAPTER),
          certificate_requests =
              value.certificate_requests.redactElements(CertificateRequest.ADAPTER),
          key_attestation = value.key_attestation?.let(KeyAttestation.ADAPTER::redact),
          unknownFields = ByteString.EMPTY
        )
      }

      private const val serialVersionUID: Long = 0L

      @JvmSynthetic
      public inline fun build(body: Builder.() -> Unit): EnrollSingleKeyRequest =
          Builder().apply(body).build()
    }

    /**
     * Cross-signatures or MAC tags by other keys.
     */
    public class KeyCrossproof(
      /**
       * The key_name of the cross-signing key.
       */
      @field:WireField(
        tag = 1,
        adapter = "com.squareup.wire.ProtoAdapter#STRING",
        label = WireField.Label.OMIT_IDENTITY,
        jsonName = "otherKeyName",
        schemaIndex = 0,
      )
      @JvmField
      public val other_key_name: String = "",
      /**
       * The computed cross-signatures or MAC tags.
       */
      @field:WireField(
        tag = 2,
        adapter = "com.squareup.wire.ProtoAdapter#BYTES",
        label = WireField.Label.OMIT_IDENTITY,
        jsonName = "otherKeyProof",
        schemaIndex = 1,
      )
      @JvmField
      public val other_key_proof: ByteString = ByteString.EMPTY,
      unknownFields: ByteString = ByteString.EMPTY,
    ) : Message<KeyCrossproof, KeyCrossproof.Builder>(ADAPTER, unknownFields) {
      override fun newBuilder(): Builder {
        val builder = Builder()
        builder.other_key_name = other_key_name
        builder.other_key_proof = other_key_proof
        builder.addUnknownFields(unknownFields)
        return builder
      }

      override fun equals(other: Any?): Boolean {
        if (other === this) return true
        if (other !is KeyCrossproof) return false
        if (unknownFields != other.unknownFields) return false
        if (other_key_name != other.other_key_name) return false
        if (other_key_proof != other.other_key_proof) return false
        return true
      }

      override fun hashCode(): Int {
        var result = super.hashCode
        if (result == 0) {
          result = unknownFields.hashCode()
          result = result * 37 + other_key_name.hashCode()
          result = result * 37 + other_key_proof.hashCode()
          super.hashCode = result
        }
        return result
      }

      override fun toString(): String {
        val result = mutableListOf<String>()
        result += """other_key_name=${sanitize(other_key_name)}"""
        result += """other_key_proof=$other_key_proof"""
        return result.joinToString(prefix = "KeyCrossproof{", separator = ", ", postfix = "}")
      }

      public fun copy(
        other_key_name: String = this.other_key_name,
        other_key_proof: ByteString = this.other_key_proof,
        unknownFields: ByteString = this.unknownFields,
      ): KeyCrossproof = KeyCrossproof(other_key_name, other_key_proof, unknownFields)

      public class Builder : Message.Builder<KeyCrossproof, Builder>() {
        @JvmField
        public var other_key_name: String = ""

        @JvmField
        public var other_key_proof: ByteString = ByteString.EMPTY

        /**
         * The key_name of the cross-signing key.
         */
        public fun other_key_name(other_key_name: String): Builder {
          this.other_key_name = other_key_name
          return this
        }

        /**
         * The computed cross-signatures or MAC tags.
         */
        public fun other_key_proof(other_key_proof: ByteString): Builder {
          this.other_key_proof = other_key_proof
          return this
        }

        override fun build(): KeyCrossproof = KeyCrossproof(
          other_key_name = other_key_name,
          other_key_proof = other_key_proof,
          unknownFields = buildUnknownFields()
        )
      }

      public companion object {
        @JvmField
        public val ADAPTER: ProtoAdapter<KeyCrossproof> = object : ProtoAdapter<KeyCrossproof>(
          FieldEncoding.LENGTH_DELIMITED, 
          KeyCrossproof::class, 
          "type.googleapis.com/cryptauthv2.EnrollKeysRequest.EnrollSingleKeyRequest.KeyCrossproof", 
          PROTO_3, 
          null, 
          "cryptauth/cryptauth_enrollment.proto"
        ) {
          override fun encodedSize(`value`: KeyCrossproof): Int {
            var size = value.unknownFields.size
            if (value.other_key_name != "") size += ProtoAdapter.STRING.encodedSizeWithTag(1,
                value.other_key_name)
            if (value.other_key_proof != ByteString.EMPTY) size +=
                ProtoAdapter.BYTES.encodedSizeWithTag(2, value.other_key_proof)
            return size
          }

          override fun encode(writer: ProtoWriter, `value`: KeyCrossproof) {
            if (value.other_key_name != "") ProtoAdapter.STRING.encodeWithTag(writer, 1,
                value.other_key_name)
            if (value.other_key_proof != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer,
                2, value.other_key_proof)
            writer.writeBytes(value.unknownFields)
          }

          override fun encode(writer: ReverseProtoWriter, `value`: KeyCrossproof) {
            writer.writeBytes(value.unknownFields)
            if (value.other_key_proof != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer,
                2, value.other_key_proof)
            if (value.other_key_name != "") ProtoAdapter.STRING.encodeWithTag(writer, 1,
                value.other_key_name)
          }

          override fun decode(reader: ProtoReader): KeyCrossproof {
            var other_key_name: String = ""
            var other_key_proof: ByteString = ByteString.EMPTY
            val unknownFields = reader.forEachTag { tag ->
              when (tag) {
                1 -> other_key_name = ProtoAdapter.STRING.decode(reader)
                2 -> other_key_proof = ProtoAdapter.BYTES.decode(reader)
                else -> reader.readUnknownField(tag)
              }
            }
            return KeyCrossproof(
              other_key_name = other_key_name,
              other_key_proof = other_key_proof,
              unknownFields = unknownFields
            )
          }

          override fun redact(`value`: KeyCrossproof): KeyCrossproof = value.copy(
            unknownFields = ByteString.EMPTY
          )
        }

        private const val serialVersionUID: Long = 0L

        @JvmSynthetic
        public inline fun build(body: Builder.() -> Unit): KeyCrossproof =
            Builder().apply(body).build()
      }
    }

    /**
     * Attestation of the key.
     */
    public class KeyAttestation(
      /**
       * The attestation type.
       */
      @field:WireField(
        tag = 1,
        adapter =
            "cryptauthv2.EnrollKeysRequest${'$'}EnrollSingleKeyRequest${'$'}KeyAttestation${'$'}KeyAttestationType#ADAPTER",
        label = WireField.Label.OMIT_IDENTITY,
        schemaIndex = 0,
      )
      @JvmField
      public val type: KeyAttestationType = KeyAttestationType.KEY_ATTESTATION_TYPE_UNSPECIFIED,
      /**
       * The payload of the key attestation. The content of the payload is
       * dependent on the attestation type.
       */
      @field:WireField(
        tag = 2,
        adapter = "com.squareup.wire.ProtoAdapter#BYTES",
        label = WireField.Label.OMIT_IDENTITY,
        schemaIndex = 1,
      )
      @JvmField
      public val payload: ByteString = ByteString.EMPTY,
      unknownFields: ByteString = ByteString.EMPTY,
    ) : Message<KeyAttestation, KeyAttestation.Builder>(ADAPTER, unknownFields) {
      override fun newBuilder(): Builder {
        val builder = Builder()
        builder.type = type
        builder.payload = payload
        builder.addUnknownFields(unknownFields)
        return builder
      }

      override fun equals(other: Any?): Boolean {
        if (other === this) return true
        if (other !is KeyAttestation) return false
        if (unknownFields != other.unknownFields) return false
        if (type != other.type) return false
        if (payload != other.payload) return false
        return true
      }

      override fun hashCode(): Int {
        var result = super.hashCode
        if (result == 0) {
          result = unknownFields.hashCode()
          result = result * 37 + type.hashCode()
          result = result * 37 + payload.hashCode()
          super.hashCode = result
        }
        return result
      }

      override fun toString(): String {
        val result = mutableListOf<String>()
        result += """type=$type"""
        result += """payload=$payload"""
        return result.joinToString(prefix = "KeyAttestation{", separator = ", ", postfix = "}")
      }

      public fun copy(
        type: KeyAttestationType = this.type,
        payload: ByteString = this.payload,
        unknownFields: ByteString = this.unknownFields,
      ): KeyAttestation = KeyAttestation(type, payload, unknownFields)

      public class Builder : Message.Builder<KeyAttestation, Builder>() {
        @JvmField
        public var type: KeyAttestationType = KeyAttestationType.KEY_ATTESTATION_TYPE_UNSPECIFIED

        @JvmField
        public var payload: ByteString = ByteString.EMPTY

        /**
         * The attestation type.
         */
        public fun type(type: KeyAttestationType): Builder {
          this.type = type
          return this
        }

        /**
         * The payload of the key attestation. The content of the payload is
         * dependent on the attestation type.
         */
        public fun payload(payload: ByteString): Builder {
          this.payload = payload
          return this
        }

        override fun build(): KeyAttestation = KeyAttestation(
          type = type,
          payload = payload,
          unknownFields = buildUnknownFields()
        )
      }

      public companion object {
        @JvmField
        public val ADAPTER: ProtoAdapter<KeyAttestation> = object : ProtoAdapter<KeyAttestation>(
          FieldEncoding.LENGTH_DELIMITED, 
          KeyAttestation::class, 
          "type.googleapis.com/cryptauthv2.EnrollKeysRequest.EnrollSingleKeyRequest.KeyAttestation",
              
          PROTO_3, 
          null, 
          "cryptauth/cryptauth_enrollment.proto"
        ) {
          override fun encodedSize(`value`: KeyAttestation): Int {
            var size = value.unknownFields.size
            if (value.type != KeyAttestationType.KEY_ATTESTATION_TYPE_UNSPECIFIED) size +=
                KeyAttestationType.ADAPTER.encodedSizeWithTag(1, value.type)
            if (value.payload != ByteString.EMPTY) size += ProtoAdapter.BYTES.encodedSizeWithTag(2,
                value.payload)
            return size
          }

          override fun encode(writer: ProtoWriter, `value`: KeyAttestation) {
            if (value.type != KeyAttestationType.KEY_ATTESTATION_TYPE_UNSPECIFIED)
                KeyAttestationType.ADAPTER.encodeWithTag(writer, 1, value.type)
            if (value.payload != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer, 2,
                value.payload)
            writer.writeBytes(value.unknownFields)
          }

          override fun encode(writer: ReverseProtoWriter, `value`: KeyAttestation) {
            writer.writeBytes(value.unknownFields)
            if (value.payload != ByteString.EMPTY) ProtoAdapter.BYTES.encodeWithTag(writer, 2,
                value.payload)
            if (value.type != KeyAttestationType.KEY_ATTESTATION_TYPE_UNSPECIFIED)
                KeyAttestationType.ADAPTER.encodeWithTag(writer, 1, value.type)
          }

          override fun decode(reader: ProtoReader): KeyAttestation {
            var type: KeyAttestationType = KeyAttestationType.KEY_ATTESTATION_TYPE_UNSPECIFIED
            var payload: ByteString = ByteString.EMPTY
            val unknownFields = reader.forEachTag { tag ->
              when (tag) {
                1 -> try {
                  type = KeyAttestationType.ADAPTER.decode(reader)
                } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
                  reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
                }
                2 -> payload = ProtoAdapter.BYTES.decode(reader)
                else -> reader.readUnknownField(tag)
              }
            }
            return KeyAttestation(
              type = type,
              payload = payload,
              unknownFields = unknownFields
            )
          }

          override fun redact(`value`: KeyAttestation): KeyAttestation = value.copy(
            unknownFields = ByteString.EMPTY
          )
        }

        private const val serialVersionUID: Long = 0L

        @JvmSynthetic
        public inline fun build(body: Builder.() -> Unit): KeyAttestation =
            Builder().apply(body).build()
      }

      /**
       * The type of the key attestation.
       */
      public enum class KeyAttestationType(
        override val `value`: Int,
      ) : WireEnum {
        /**
         * Default value.
         */
        KEY_ATTESTATION_TYPE_UNSPECIFIED(0),
        /**
         * Attestation generated by Android KeyStore API.
         * See
         * https://developer.android.com/training/articles/security-key-attestation
         * The payload should be the concatenation of the X.509
         * certificates returned by KeyStore attestation API encoded in ASN.1
         * DER.
         */
        ANDROID_KEYSTORE_ATTESTATION(1),
        ;

        public companion object {
          @JvmField
          public val ADAPTER: ProtoAdapter<KeyAttestationType> = object :
              EnumAdapter<KeyAttestationType>(
            KeyAttestationType::class, 
            PROTO_3, 
            KeyAttestationType.KEY_ATTESTATION_TYPE_UNSPECIFIED
          ) {
            override fun fromValue(`value`: Int): KeyAttestationType? =
                KeyAttestationType.fromValue(`value`)
          }

          @JvmStatic
          public fun fromValue(`value`: Int): KeyAttestationType? = when (`value`) {
            0 -> KEY_ATTESTATION_TYPE_UNSPECIFIED
            1 -> ANDROID_KEYSTORE_ATTESTATION
            else -> null
          }
        }
      }
    }
  }
}
